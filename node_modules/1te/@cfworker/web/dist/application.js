import statuses from 'statuses';
import { Context } from './context.js';
import { HttpError } from './http-error.js';
import { composeMiddleware } from './middleware.js';
const resolved = Promise.resolve();
export class Application {
    constructor() {
        this.middleware = [];
    }
    use(middleware) {
        this.middleware.push(middleware);
        return this;
    }
    listen() {
        const middleware = composeMiddleware(this.middleware);
        addEventListener('fetch', event => this.handleFetch(event, middleware));
    }
    handleFetch(event, middleware) {
        const context = new Context(event);
        event.respondWith(Promise.race([
            this.invokeMiddleware(context, middleware),
            context.responded
        ]));
    }
    async invokeMiddleware(context, middleware) {
        try {
            await middleware(context, () => resolved);
            return context.res.create();
        }
        catch (err) {
            console.error(err.stack || err.toString());
            if (err instanceof HttpError) {
                return err.toResponse();
            }
            const status = 500;
            const statusText = statuses[500];
            const headers = { 'content-type': 'text/plain' };
            return new Response(statusText, { status, statusText, headers });
        }
    }
}
