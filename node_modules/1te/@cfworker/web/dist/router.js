import { pathToRegexp } from 'path-to-regexp';
import { HttpError } from './http-error.js';
import { composeMiddleware } from './middleware.js';
export const Method = (method) => {
    method = method.toUpperCase();
    return ({ req }) => req.method === method;
};
export const Get = Method('get');
export const Post = Method('post');
export const Put = Method('put');
export const Patch = Method('patch');
export const Delete = Method('delete');
export const Head = Method('head');
export const Options = Method('options');
export const Header = (header, value) => {
    value = value.toLowerCase();
    return ({ req }) => req.headers.get(header) === value;
};
export const Host = (host) => Header('host', host);
export const Referer = (host) => Header('referer', host);
export const Path = (pattern) => {
    const keys = [];
    const regExp = pathToRegexp(pattern, keys);
    return ({ req: { url, params } }) => {
        const match = url.pathname.match(regExp);
        if (!match) {
            return false;
        }
        collectParameters(keys, match, params);
        return true;
    };
};
export class Router {
    constructor() {
        this.middleware = async (ctx, next) => {
            const resolved = this.resolve(ctx);
            if (resolved) {
                await resolved.middleware(ctx, next);
            }
            else {
                await next();
            }
        };
        this.routes = [];
    }
    get(pathname, ...middleware) {
        return this.compose([Get, Path(pathname)], ...middleware);
    }
    post(pathname, ...middleware) {
        return this.compose([Post, Path(pathname)], ...middleware);
    }
    put(pathname, ...middleware) {
        return this.compose([Put, Path(pathname)], ...middleware);
    }
    patch(pathname, ...middleware) {
        return this.compose([Patch, Path(pathname)], ...middleware);
    }
    delete(pathname, ...middleware) {
        return this.compose([Delete, Path(pathname)], ...middleware);
    }
    head(pathname, ...middleware) {
        return this.compose([Head, Path(pathname)], ...middleware);
    }
    all(...middleware) {
        return this.compose([], ...middleware);
    }
    compose(conditions, ...middleware) {
        this.routes.push({
            conditions,
            middleware: composeMiddleware(middleware)
        });
        return this;
    }
    resolve(ctx) {
        return this.routes.find(({ conditions }) => conditions.length === 0 || conditions.every(c => c(ctx)));
    }
}
function collectParameters(keys, match, params) {
    for (let i = 1; i < match.length; i++) {
        const name = keys[i - 1].name;
        const value = match[i];
        if (!value) {
            continue;
        }
        params[name] = decodePathnameComponent(value);
    }
}
function decodePathnameComponent(component) {
    if (component.length === 0) {
        return component;
    }
    try {
        return decodeURIComponent(component);
    }
    catch (err) {
        if (err instanceof URIError) {
            throw new HttpError(400, `Unable to decode pathname component "${component}".`);
        }
        throw err;
    }
}
